#!/usr/bin/env python3
"""
Android CFG Strongly Connected Components (SCC) Analyzer
Analyzes DOT files generated from Android app-level CFGs to find SCCs using NetworkX
"""

import networkx as nx
import argparse
import os
import sys
from collections import defaultdict, Counter
import json

class AndroidCFGSCCAnalyzer:
    def __init__(self, dot_file_path):
        """
        Initialize the SCC analyzer with a DOT file
        
        Args:
            dot_file_path (str): Path to the DOT file generated by AppLevelCFGBuilder
        """
        self.dot_file_path = dot_file_path
        self.graph = None
        self.sccs = []
        self.scc_info = {}
        
    def load_dot_file(self):
        """Load the DOT file into a NetworkX directed graph"""
        try:
            print(f"Loading DOT file: {self.dot_file_path}")
            self.graph = nx.drawing.nx_pydot.read_dot(self.dot_file_path)
            
            # Convert to directed graph if not already
            if not isinstance(self.graph, nx.DiGraph):
                self.graph = self.graph.to_directed()
                
            print(f"Graph loaded successfully:")
            print(f"  Nodes: {self.graph.number_of_nodes()}")
            print(f"  Edges: {self.graph.number_of_edges()}")
            return True
            
        except Exception as e:
            print(f"Error loading DOT file: {e}")
            return False
    
    def find_sccs(self):
        """Find all strongly connected components using Tarjan's algorithm"""
        if self.graph is None:
            print("Error: Graph not loaded. Call load_dot_file() first.")
            return False
            
        print("\nFinding Strongly Connected Components...")
        
        # Use Tarjan's algorithm (default in NetworkX)
        self.sccs = list(nx.strongly_connected_components(self.graph))
        
        print(f"Found {len(self.sccs)} strongly connected components")
        return True
    
    def analyze_sccs(self):
        """Analyze the found SCCs and categorize them"""
        if not self.sccs:
            print("Error: No SCCs found. Call find_sccs() first.")
            return False
            
        print("\n=== SCC Analysis ===")
        
        # Categorize SCCs by size
        scc_sizes = [len(scc) for scc in self.sccs]
        size_distribution = Counter(scc_sizes)
        
        print(f"SCC Size Distribution:")
        for size in sorted(size_distribution.keys()):
            count = size_distribution[size]
            print(f"  Size {size}: {count} SCCs")
        
        # Identify significant SCCs (size > 1)
        significant_sccs = [scc for scc in self.sccs if len(scc) > 1]
        trivial_sccs = [scc for scc in self.sccs if len(scc) == 1]
        
        print(f"\nSCC Categories:")
        print(f"  Trivial SCCs (single nodes): {len(trivial_sccs)}")
        print(f"  Non-trivial SCCs (cycles): {len(significant_sccs)}")
        
        # Analyze significant SCCs
        self.scc_info = {
            'total_sccs': len(self.sccs),
            'trivial_sccs': len(trivial_sccs),
            'significant_sccs': len(significant_sccs),
            'size_distribution': dict(size_distribution),
            'largest_scc_size': max(scc_sizes) if scc_sizes else 0,
            'scc_details': []
        }
        
        # Store detailed info for significant SCCs
        for i, scc in enumerate(significant_sccs):
            scc_detail = {
                'scc_id': i + 1,
                'size': len(scc),
                'nodes': list(scc),
                'node_types': self._categorize_scc_nodes(scc)
            }
            self.scc_info['scc_details'].append(scc_detail)
        
        return True
    
    def _categorize_scc_nodes(self, scc_nodes):
        """Categorize nodes in an SCC by their method/component type"""
        categories = {
            'activities': [],
            'services': [],
            'broadcast_receivers': [],
            'lifecycle_methods': [],
            'event_handlers': [],
            'other_methods': []
        }
        
        for node in scc_nodes:
            node_str = str(node).lower()
            
            if 'activity' in node_str:
                categories['activities'].append(node)
            elif 'service' in node_str:
                categories['services'].append(node)
            elif 'receiver' in node_str or 'broadcast' in node_str:
                categories['broadcast_receivers'].append(node)
            elif any(lifecycle in node_str for lifecycle in ['oncreate', 'onresume', 'onpause', 'ondestroy']):
                categories['lifecycle_methods'].append(node)
            elif any(event in node_str for event in ['onclick', 'ontouch', 'onkey']):
                categories['event_handlers'].append(node)
            else:
                categories['other_methods'].append(node)
                
        return {k: v for k, v in categories.items() if v}  # Only return non-empty categories
    
    def print_detailed_scc_analysis(self):
        """Print detailed analysis of significant SCCs"""
        if not self.scc_info:
            print("Error: SCC analysis not performed. Call analyze_sccs() first.")
            return
            
        significant_sccs = self.scc_info['scc_details']
        
        if not significant_sccs:
            print("\nNo significant SCCs found (all nodes are in trivial SCCs)")
            return
            
        print(f"\n=== Detailed SCC Analysis ===")
        print(f"Found {len(significant_sccs)} significant SCCs with cycles\n")
        
        for scc_detail in significant_sccs:
            print(f"SCC #{scc_detail['scc_id']} (Size: {scc_detail['size']})")
            print("-" * 50)
            
            # Print node categories
            node_types = scc_detail['node_types']
            for category, nodes in node_types.items():
                if nodes:
                    print(f"  {category.replace('_', ' ').title()}: {len(nodes)}")
                    for node in nodes[:3]:  # Show first 3 nodes
                        node_name = self._extract_node_name(str(node))
                        print(f"    - {node_name}")
                    if len(nodes) > 3:
                        print(f"    ... and {len(nodes) - 3} more")
            
            print(f"  Total nodes in cycle: {scc_detail['size']}")
            print()
    
    def _extract_node_name(self, full_node_id):
        """Extract readable node name from full node ID"""
        # Handle different node ID formats from the CFG
        if '_block_' in full_node_id:
            parts = full_node_id.split('_block_')
            if len(parts) == 2:
                signature = parts[0]
                block_id = parts[1]
                
                # Extract method name from signature
                if ': ' in signature and ' ' in signature:
                    try:
                        method_part = signature.split(': ')[1]
                        method_name = method_part.split(' ')[1]
                        if '(' in method_name:
                            method_name = method_name.split('(')[0]
                        return f"{method_name}_block_{block_id}"
                    except:
                        pass
        
        return full_node_id[:50] + "..." if len(full_node_id) > 50 else full_node_id
    
    def identify_problematic_sccs(self):
        """Identify SCCs that might cause issues for symbolic execution"""
        if not self.scc_info:
            return []
            
        problematic = []
        
        for scc_detail in self.scc_info['scc_details']:
            risk_level = "LOW"
            reasons = []
            
            # Large SCCs are more problematic
            if scc_detail['size'] > 10:
                risk_level = "HIGH"
                reasons.append(f"Large cycle ({scc_detail['size']} nodes)")
            elif scc_detail['size'] > 5:
                risk_level = "MEDIUM"
                reasons.append(f"Medium cycle ({scc_detail['size']} nodes)")
            
            # Multiple component types in one SCC indicates complex interactions
            node_types = scc_detail['node_types']
            if len(node_types) > 2:
                if risk_level == "LOW":
                    risk_level = "MEDIUM"
                reasons.append(f"Multiple component types ({len(node_types)})")
            
            # Event handlers in cycles can cause infinite loops during symbolic execution
            if 'event_handlers' in node_types and len(node_types['event_handlers']) > 0:
                if risk_level != "HIGH":
                    risk_level = "MEDIUM"
                reasons.append("Contains event handlers")
            
            if risk_level != "LOW":
                problematic.append({
                    'scc_id': scc_detail['scc_id'],
                    'size': scc_detail['size'],
                    'risk_level': risk_level,
                    'reasons': reasons,
                    'node_types': list(node_types.keys())
                })
        
        return problematic
    
    def save_results(self, output_file):
        """Save SCC analysis results to JSON file"""
        if not self.scc_info:
            print("Error: No analysis results to save")
            return False
            
        try:
            # Add problematic SCC analysis
            problematic_sccs = self.identify_problematic_sccs()
            self.scc_info['problematic_sccs'] = problematic_sccs
            
            # Convert sets to lists for JSON serialization
            json_data = self._prepare_for_json(self.scc_info)
            
            with open(output_file, 'w') as f:
                json.dump(json_data, f, indent=2)
            
            print(f"Analysis results saved to: {output_file}")
            return True
            
        except Exception as e:
            print(f"Error saving results: {e}")
            return False
    
    def _prepare_for_json(self, data):
        """Convert data structures for JSON serialization"""
        if isinstance(data, dict):
            return {k: self._prepare_for_json(v) for k, v in data.items()}
        elif isinstance(data, list):
            return [self._prepare_for_json(item) for item in data]
        elif isinstance(data, set):
            return list(data)
        else:
            return str(data) if not isinstance(data, (int, float, bool, str, type(None))) else data
    
    def print_summary(self):
        """Print summary of SCC analysis"""
        if not self.scc_info:
            print("No analysis results available")
            return
            
        print(f"\n=== SCC Analysis Summary ===")
        print(f"DOT File: {os.path.basename(self.dot_file_path)}")
        print(f"Total Nodes: {self.graph.number_of_nodes()}")
        print(f"Total Edges: {self.graph.number_of_edges()}")
        print(f"Total SCCs: {self.scc_info['total_sccs']}")
        print(f"Trivial SCCs: {self.scc_info['trivial_sccs']}")
        print(f"Significant SCCs: {self.scc_info['significant_sccs']}")
        print(f"Largest SCC Size: {self.scc_info['largest_scc_size']}")
        
        # Print problematic SCCs
        problematic = self.identify_problematic_sccs()
        if problematic:
            print(f"\nProblematic SCCs for Symbolic Execution:")
            for scc in problematic:
                print(f"  SCC #{scc['scc_id']}: {scc['risk_level']} risk - {', '.join(scc['reasons'])}")
        else:
            print(f"\nNo problematic SCCs identified - good for symbolic execution!")

def main():
    parser = argparse.ArgumentParser(description='Analyze Android CFG DOT files for Strongly Connected Components')
    parser.add_argument('dot_file', help='Path to the DOT file to analyze')
    parser.add_argument('-o', '--output', help='Output JSON file for detailed results')
    parser.add_argument('-v', '--verbose', action='store_true', help='Show detailed SCC analysis')
    
    args = parser.parse_args()
    
    if not os.path.exists(args.dot_file):
        print(f"Error: DOT file not found: {args.dot_file}")
        sys.exit(1)
    
    # Create analyzer and run analysis
    analyzer = AndroidCFGSCCAnalyzer(args.dot_file)
    
    if not analyzer.load_dot_file():
        sys.exit(1)
    
    if not analyzer.find_sccs():
        sys.exit(1)
    
    if not analyzer.analyze_sccs():
        sys.exit(1)
    
    # Print results
    analyzer.print_summary()
    
    if args.verbose:
        analyzer.print_detailed_scc_analysis()
    
    # Save results if requested
    if args.output:
        analyzer.save_results(args.output)

if __name__ == "__main__":
    main()
